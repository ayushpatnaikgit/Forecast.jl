<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Featured Methods · Forecast.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Forecast.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Forecast.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">What is this about?</a></li><li><a class="tocitem" href="../quickstart/">Quick Start</a></li><li><span class="tocitem">Forecast Examples</span><ul><li><a class="tocitem" href="../examples/quakes/">Quakes (Univariate)</a></li><li><a class="tocitem" href="../examples/airpassengers/">Air Passengers (Seasonality)</a></li><li><a class="tocitem" href="../examples/london/">London Weather/Crime (Multivariate)</a></li><li><a class="tocitem" href="../examples/whatif/">WHAT-IF Scenarios</a></li></ul></li><li class="is-active"><a class="tocitem" href>Featured Methods</a><ul class="internal"><li><a class="tocitem" href="#acf"><span>acf</span></a></li><li><a class="tocitem" href="#ar"><span>ar</span></a></li><li><a class="tocitem" href="#arsim"><span>arsim</span></a></li><li><a class="tocitem" href="#boxcox"><span>boxcox</span></a></li><li><a class="tocitem" href="#ccf"><span>ccf</span></a></li><li><a class="tocitem" href="#d"><span>d</span></a></li><li><a class="tocitem" href="#forecast"><span>forecast</span></a></li><li><a class="tocitem" href="#iboxcox"><span>iboxcox</span></a></li><li><a class="tocitem" href="#loess"><span>loess</span></a></li><li><a class="tocitem" href="#p"><span>p</span></a></li><li><a class="tocitem" href="#splot"><span>splot</span></a></li><li><a class="tocitem" href="#stl"><span>stl</span></a></li><li><a class="tocitem" href="#summarize"><span>summarize</span></a></li></ul></li><li><a class="tocitem" href="../datasets/">Datasets</a></li><li><a class="tocitem" href="../docstrings/">Docstrings</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Featured Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Featured Methods</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/viraltux/Forecast.jl/blob/master/docs/src/man/methods.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Featured-Methods"><a class="docs-heading-anchor" href="#Featured-Methods">Featured Methods</a><a id="Featured-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Featured-Methods" title="Permalink"></a></h1><pre><code class="language-none">acf:        Auto-correlation or auto-covariance of univariate series. 
ar:         Multivariate Autoregressive Model.
arsim:      Simulated Multivariate Autoregressive Model.
ccf:        Cross-correlation or cros-covariance of two univariate series.
d:          Lagged differences of a given order for Vector and Array
forecast:   Forecast values of fitted time series models.
hma:        Henderson moving average filter.
loess:      Locally estimated scatterplot smoothing.
p:          Reverse lagged differences of a given order for types Vector and Array.
pacf:       Partial Auto-correlation function.
sma:        Simple moving average.
splot:      Plot a seasonal plot for types Vector and TimeArray.
stl:        Seasonal and Trend decomposition using loess.
summarize:  Statistical summary.</code></pre><h2 id="acf"><a class="docs-heading-anchor" href="#acf">acf</a><a id="acf-1"></a><a class="docs-heading-anchor-permalink" href="#acf" title="Permalink"></a></h2><p><strong>Auto-correlation/covariance function</strong></p><article class="docstring"><header><a class="docstring-binding" id="Forecast.acf" href="#Forecast.acf"><code>Forecast.acf</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">acf(x::{AbstractVector,DataFrame},
    type = &quot;cor&quot;,
    lag = Integer(ceil(10*log10(length(x)))),
    alpha = (0.95,0.99))</code></pre><p>Compute the auto-correlation or auto-covariance for an univariate series.</p><p>The results are normalized to preserve homoscedasticity. The distribution used to normalize the data is an approximation of a Fisher Transformation via a Normal Distribution. There is a plot recipe for the returned object, if the type is <code>cor</code> the plot will also show confidence intervals for the given alpha values.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Vector or uni-dimensional DataFrame of data.</li><li><code>type</code>: Valid values are &quot;cor&quot; for correlation (default) and &quot;cov&quot; for convariance.</li><li><code>lag</code>: Maximum number of lags.</li><li><code>alpha</code>: A tuple with two thresholds (t1,t2) with t1 &lt;= t2 to plot confidence intervals. The default values are 0.95 and 0.99.</li></ul><p><strong>Returns</strong></p><p>A CCF object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = rand(100);
res = acf(x; type=&quot;cor&quot;);
plot(res)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/f52975815e3ef251d5f903a55cc262b5dbe6e7c5/src/acf.jl#L1-L28">source</a></section></article><h2 id="ar"><a class="docs-heading-anchor" href="#ar">ar</a><a id="ar-1"></a><a class="docs-heading-anchor-permalink" href="#ar" title="Permalink"></a></h2><p><strong>Autoregressive model</strong></p><article class="docstring"><header><a class="docstring-binding" id="Forecast.ar" href="#Forecast.ar"><code>Forecast.ar</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">ar(x::DataFrame, or, constant = true;             
                 alpha = 1.0, dΦ0 = nothing, dΦ = nothing)

ar(x::AbstractArray, or, constant = true; 
                     alpha = false, dΦ0 = nothing, dΦ = nothing, varnames = nothing)</code></pre><p>Fit a multivariate autoregressive series model.</p><p>The fitting is done via Ordinary Least Squared and implements the following model:</p><p class="math-container">\[Xt = \Phi_0 + \sum_{i=1}^p \Phi_i \cdot X_{t-i} + \mathcal{N}(\vec{0},\Sigma)\]</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Multivariate series each column containing a dimension and ordered by time ascending rows.</li><li><code>or</code>: Number of parameters Φ to be estimated.</li><li><code>constant</code>: If <code>true</code> <code>ar</code> estimates Φ0 otherwise it is assume to be zero.</li><li><code>alpha</code>: fixes to zero all coefficients which significance is below its value. It defaults to one.</li><li><code>dΦ0</code>: Tuple containing two Φ0 objects, the first one will act as an original reference to the second one and different values will be fixed in the fitting process to the values in the second Φ0.</li><li><code>dΦ</code>:  Equivalent to dΦ0 but for Φ.</li><li><code>varnames</code>: Names of the dimensions (by default xi where <code>i</code> is an integer)</li></ul><p><strong>Returns</strong></p><p>An AR object containing the model coefficients, the error sigma matrix, residuals and a collection of information criteria</p><p><strong>Examples</strong></p><p>```julia-repl julia&gt; ar(rand(100,2),2) AR([...])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/f52975815e3ef251d5f903a55cc262b5dbe6e7c5/src/ar.jl#L1-L34">source</a></section></article><h2 id="arsim"><a class="docs-heading-anchor" href="#arsim">arsim</a><a id="arsim-1"></a><a class="docs-heading-anchor-permalink" href="#arsim" title="Permalink"></a></h2><p><strong>Autoregressive simulation</strong></p><article class="docstring"><header><a class="docstring-binding" id="Forecast.arsim" href="#Forecast.arsim"><code>Forecast.arsim</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">arsim(Φ,Φ0,x0,n; Σ,E,fix)
arsim(AR,n;fix)</code></pre><p>Simulate a multivariate autoregressive series model.</p><p>The simulated series follows the model:</p><p class="math-container">\[Xt = \Phi_0 + \sum_{i=1}^p \Phi_i \cdot X_{t-i} + E\]</p><p><strong>Arguments</strong></p><ul><li><p><code>AR</code>:           AR struct coming from an <code>ar</code> model.</p></li><li><p><code>Φ</code>:            Array with dimensions (m,m,p) for the parameters in the AR model.</p></li><li><p><code>Φ0</code>:           Vector size <code>m</code> for the constant in the AR model. Default value is 0.</p></li><li><p><code>x0</code>:           Array with dimensions (m,p) for the initial value in the AR model. Default value is a random value from zero to one.</p></li><li><p><code>n</code>:            Number of simulations.</p></li><li><p><code>fix</code>:          Matrix{Union{Missing,Float64}} containing values to be fixed in th simulation.</p></li><li><p><code>Σ2</code>:           Variance Covariance matrix for the AR model with a MvNormal distribution for the noise. Default value is an identity Matrix.</p></li><li><p><code>E</code>:            Distribution for the error.</p></li></ul><p><strong>Returns</strong></p><p>A multivariate series simulating an AR model each column containing a dimension and ordered by time ascending rows.</p><p><strong>Examples</strong></p><p>```julia-repl julia&gt; arsim(1,1,1,10) 10-element Vector{Float64,1}: [...]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/f52975815e3ef251d5f903a55cc262b5dbe6e7c5/src/arsim.jl#L1-L35">source</a></section></article><h2 id="boxcox"><a class="docs-heading-anchor" href="#boxcox">boxcox</a><a id="boxcox-1"></a><a class="docs-heading-anchor-permalink" href="#boxcox" title="Permalink"></a></h2><p><strong>Autoregressive simulation</strong></p><article class="docstring"><header><a class="docstring-binding" id="Forecast.boxcox" href="#Forecast.boxcox"><code>Forecast.boxcox</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">boxcox(x::Vector)
boxcox(x::Vector, λ::Float64)  
boxcox(x::Vector, λ::Vector)</code></pre><p>Compute a Box-Cox power transformation given λ or (λ1,λ2) for data containing negative values, or compute an optimal power transformation if no λ or (λ1,λ2) is provided.</p><p class="math-container">\[x(\lambda) =
\begin{cases}
 \dfrac{x_i^\lambda - 1}{\lambda} &amp; \text{if } \lambda \neq 0 \\
 \ln x_i &amp; \text{if } \lambda = 0
\end{cases}\]</p><p>for negative values</p><p class="math-container">\[x(\boldsymbol{\lambda}) =
\begin{cases}
 \dfrac{(x_i + \lambda_2)^{\lambda_1} - 1}{\lambda_1} &amp; \text{if } \lambda_1 \neq 0 \\
 \ln (x_i + \lambda_2) &amp; \text{if } \lambda_1 = 0
\end{cases} \]</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Vector to be transformed.</li><li><code>λ</code>: Exponent/s for the tranformation</li></ul><p><strong>Returns</strong></p><p>A vector with a boxcox tarnsformation for <code>x</code> or a Dict with :x boxcox tranformed and the optimal :λ</p><p><strong>Reference</strong></p><p>Box, G. E. P. and Cox, D. R. (1964). An analysis of transformations, Journal of the Royal Statistical Society, Series B, 26, 211-252. A</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = rand(100)
julia&gt; bc = boxcox(x)
julia&gt; iboxcox(bc[:x],bc[:λ]) ≈ x

julia&gt; x = rand(100) .- 0.5
julia&gt; bc = boxcox(x)
julia&gt; iboxcox(bc[:x],bc[:λ]) ≈ x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/f52975815e3ef251d5f903a55cc262b5dbe6e7c5/src/boxcox.jl#L2-L48">source</a></section></article><h2 id="ccf"><a class="docs-heading-anchor" href="#ccf">ccf</a><a id="ccf-1"></a><a class="docs-heading-anchor-permalink" href="#ccf" title="Permalink"></a></h2><p><strong>Cros-correlation/covariance function</strong></p><article class="docstring"><header><a class="docstring-binding" id="Forecast.ccf" href="#Forecast.ccf"><code>Forecast.ccf</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">ccf(x1::{AbstractVector,DataFrame},
    x2::{AbstractVector,DataFrame};
    type = &quot;cor&quot;,
    lag = Integer(ceil(10*log10(length(x1)))),
    alpha = (0.95,0.99))</code></pre><p>Compute the cross-correlation or cros-covariance of two univariate series.</p><p>The results are normalized to preserve homoscedasticity. The distribution used to normalize the data is an approximation of a Fisher Transformation via a Normal Distribution. There is a plot recipe for the returned object, if the type is <code>cor</code> the plot will also show confidence intervals for the given alpha values.</p><p>If, for a given integer <code>k</code>, <code>x2</code> repeats <code>x1</code> values such that x1[t] = x2[t+k] for all <code>i</code> then high correlation value will be placed <em>at the right from the center</em> in the results. That is, this convention will be represented in the plots as <code>x1_t = x2_{t+k} -&gt; _____0__k__</code> meaning x2 behavior can be predicted by x1 in k units.</p><p><strong>Arguments</strong></p><ul><li><code>x1</code>: Vector or uni-dimensional DataFrame of data.</li><li><code>x2</code>: Vector or uni-dimensional DataFrame of data.</li><li><code>type</code>: Valid values are &quot;cor&quot; for correlation (default) and &quot;cov&quot; for convariance.</li><li><code>lag</code>: Maximum number of lags.</li><li><code>alpha</code>: A tuple with two thresholds (t1,t2) with t1 &lt;= t2 to plot confidence intervals. The default values are 0.95 and 0.99.</li></ul><p><strong>Returns</strong></p><p>A CCF object. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x1 = rand(100);
x2 = circshift(x1,6);
res = ccf(x1, x2; type=&quot;cor&quot;);
plot(res)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/f52975815e3ef251d5f903a55cc262b5dbe6e7c5/src/ccf.jl#L1-L33">source</a></section></article><h2 id="d"><a class="docs-heading-anchor" href="#d">d</a><a id="d-1"></a><a class="docs-heading-anchor-permalink" href="#d" title="Permalink"></a></h2><p><strong>Lagged differences of a given order</strong></p><article class="docstring"><header><a class="docstring-binding" id="Forecast.d" href="#Forecast.d"><code>Forecast.d</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">function d(x::{AbstractVector,AbstractArray,DataFrame},
           or::Int=1,
           la::Int=1;
           center::Bool=false)</code></pre><p>Return Laged differences of a given or for Vector, Array and TimeSeries.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Vector or Array of data.</li><li><code>or</code>: Order of the differences; number of recursive iterations on the same vector/array.</li><li><code>la</code>: Lag for the difference.</li><li><code>center</code>: Center the result in the response using Missing values.</li></ul><p><strong>Returns</strong></p><p>Laged differences Vector or Array of a given order.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = [1,2,3,4,5];
julia&gt; d(x)
 d(x)
4-element Vector{Int64}:
 1
 1
 1
 1

julia&gt; d(x,2)
3-element Vector{Int64}:
 0
 0
 0


julia&gt; d(x,1,2)
3-element Vector{Int64}:
 2
 2
 2

julia&gt; x = reshape(collect(1:20),10,2);

julia&gt; d(x,2,2)
6×2 Matrix{Int64}:
 0  0
 0  0
 0  0
 0  0
 0  0
 0  0

julia&gt; d(d(x,1,2),1,2) == d(x,2,2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/f52975815e3ef251d5f903a55cc262b5dbe6e7c5/src/d.jl#L1-L57">source</a></section></article><h2 id="forecast"><a class="docs-heading-anchor" href="#forecast">forecast</a><a id="forecast-1"></a><a class="docs-heading-anchor-permalink" href="#forecast" title="Permalink"></a></h2><p><strong>Forecast for models</strong></p><article class="docstring"><header><a class="docstring-binding" id="Forecast.forecast" href="#Forecast.forecast"><code>Forecast.forecast</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">forecast(xar, n; levels = (0.8,.95))</code></pre><p>Forecast a univariate or multivariate autoregressive model.</p><p>The forecasting follows the model:</p><p class="math-container">\[Xt = \Phi_0 + \sum_{i=1}^p \Phi_i \cdot X_{t-i} + E\]</p><p><strong>Arguments</strong></p><p><code>xar</code>           AR struct coming from the <code>ar</code> function. <code>n</code>             Number of time periods to be forecasted. <code>alpha</code>         Prediction intervals levels; its default value is (0.8, 0.95) <code>fixMean</code>       Fixes the mean in the forecast with a DataFrame which first                  column is a timestamp type and missing values indicate values                 to be estimated. Default value is <code>nothing</code>. <code>fixΣ2</code>         fixes Σ2 values in the forecast</p><p><strong>Returns</strong></p><p>A FORECAST struct</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/f52975815e3ef251d5f903a55cc262b5dbe6e7c5/src/forecast_ar.jl#L1-L25">source</a></section></article><h2 id="iboxcox"><a class="docs-heading-anchor" href="#iboxcox">iboxcox</a><a id="iboxcox-1"></a><a class="docs-heading-anchor-permalink" href="#iboxcox" title="Permalink"></a></h2><p><strong>Autoregressive simulation</strong></p><article class="docstring"><header><a class="docstring-binding" id="Forecast.iboxcox" href="#Forecast.iboxcox"><code>Forecast.iboxcox</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">iboxcox(x::Vector, λ::Float64) 
iboxcox(x::Vector, λ::Vector)</code></pre><p>Compute the inverse transformation of a Box-Cox power transformation given λ.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Vector with a boxcox tranformation to be inverted.</li><li><code>λ</code>: Exponent for the inverse tranformation.</li></ul><p><strong>Returns</strong></p><p>A vector with witht the inverse transformation of x given λ.</p><p><strong>Reference</strong></p><p>Box, G. E. P. and Cox, D. R. (1964). An analysis of transformations, Journal of the Royal Statistical Society, Series B, 26, 211-252. A</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = rand(100)
julia&gt; bc = boxcox(x)
julia&gt; iboxcox(bc[:x],bc[:λ]) ≈ x

julia&gt; x = rand(100) .- 0.5
julia&gt; bc = boxcox(x)
julia&gt; iboxcox(bc[:x],bc[:λ]) ≈ x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/f52975815e3ef251d5f903a55cc262b5dbe6e7c5/src/boxcox.jl#L70-L98">source</a></section></article><h2 id="loess"><a class="docs-heading-anchor" href="#loess">loess</a><a id="loess-1"></a><a class="docs-heading-anchor-permalink" href="#loess" title="Permalink"></a></h2><p><strong>Locally Estimated Scatterplot Smoothing (LOESS)</strong></p><article class="docstring"><header><a class="docstring-binding" id="Forecast.loess" href="#Forecast.loess"><code>Forecast.loess</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">loess(xv, yv;
      d = 2,
      q = Int64(round(3/4*length(xv))),
      rho = repeat([1.0],inner=length(xv)),  
      predict = xv)</code></pre><p>Smooth a vector of observations using locally weighted regressions.</p><p>Although loess can be used to smooth observations for any given number of independent variables, this implementation is univariate. The speed of loess can be greatly increased by using fast aproximations for the linear fitting calculations, however this implementation calculates only exact results.</p><p>The loess functionality and nomenclature follows the descriptions in:</p><p>&quot;STL: A Seasonal, Trend Decomposition Procedure Based on Loess&quot; Robert B. Cleveland, William S. Cleveland, Jean E. McRae, and Irma Terpenning. Journal of Official Statistics Vol. 6. No. 1, 1990, pp. 3-73 (c) Statistics Sweden.</p><p><strong>Arguments</strong></p><ul><li><code>xv</code>: Observations&#39; support.</li><li><code>yv</code>: Observation values.</li><li><code>d</code>: Degree of the linear fit, it accepts values 1 or 2.</li><li><code>q</code>: As q increases loess becomes smoother, when q tends to infinity loess tends to an ordinary least square poynomial fit of degree <code>d</code>. It defaults to the rounding of 3/4 of xv&#39;s length.<ul><li><code>rho</code>: Weights expressing the reliability of the observations (e.g. if yi had variances σ^2*ki where ki where known, the rhoi could be 1/ki). It defaults to 1.0.</li></ul></li><li><code>predict</code>: Vector containing the real values to be predicted, by default predicts xv.</li></ul><p><strong>Returns</strong></p><p>The loess values for the values contained in <code>predict</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; loess(rand(5), rand(5); predict=rand(10))
10-element Array{Float64,1}:
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/f52975815e3ef251d5f903a55cc262b5dbe6e7c5/src/loess.jl#L36-L72">source</a></section></article><h2 id="p"><a class="docs-heading-anchor" href="#p">p</a><a id="p-1"></a><a class="docs-heading-anchor-permalink" href="#p" title="Permalink"></a></h2><p><strong>Inverse lagged differences of a given order</strong></p><article class="docstring"><header><a class="docstring-binding" id="Forecast.p" href="#Forecast.p"><code>Forecast.p</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">function p(dx, x0)</code></pre><p>Return reverse lagged differences of a given order for Vector, Array and DataFrame.</p><p><strong>Arguments</strong></p><ul><li><code>dx</code>: Array or DataFrame of data.</li><li><code>x0</code>: Initial constants the reverse difference. The default value represents an integration of order one and lag one with initial values at zero. The format for the initial values is Array{Real,3}(order, variable, lag)&quot;</li></ul><p><strong>Returns</strong></p><p>Lagged differences Vector or Array of a given order.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">
# Order two with Lag two
julia&gt; x = repeat(1:2,30);
julia&gt; dx = d(x,2,2);
julia&gt; x0 = zeros(2,1,2); # lag 2, 1 variable, order 1
julia&gt; x0[1,:,:] = collect(1:2);
julia&gt; p(dx,x0) ≈ x
true

# Calculation of π
julia&gt; x = 0:0.001:1;
julia&gt; y = sqrt.(1 .- x.^2);
julia&gt; isapprox(4*p(y)[end]/1000 , π, atol = 0.01)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/f52975815e3ef251d5f903a55cc262b5dbe6e7c5/src/p.jl#L1-L33">source</a></section></article><h2 id="splot"><a class="docs-heading-anchor" href="#splot">splot</a><a id="splot-1"></a><a class="docs-heading-anchor-permalink" href="#splot" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Forecast.splot" href="#Forecast.splot"><code>Forecast.splot</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">splot(x, labels)</code></pre><p>Plot a seasonal plot of x considering the parameter <code>labels</code></p><p><strong>Arguments</strong></p><ul><li><code>x</code>: regular timed observations</li><li><code>labels</code>: This parameter accepts Integer, String and Vector values. When an Integer the labels are 1:labels, when a Vector the labels are specified within and when a String it accepts values &quot;month&quot;, &quot;day&quot; and &quot;quarter&quot; expecting the first value of x to fall in &quot;Jan&quot;, &quot;Mon&quot; or &quot;Q1&quot; unless x is a DataFrame in which case it is treated as a Time Series where the first Date typed column and value columns ares considered, observations are then automatically ordered either by &quot;month&quot;, &quot;day&quot; or &quot;quarter&quot; and labels may be use to rename the default values.</li></ul><p><strong>Returns</strong></p><p>Sesonal plot</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; splot(rand(120),&quot;month&quot;)
julia&gt; splot(rand(120),&quot;quarter&quot;)
julia&gt; splot(rand(120),&quot;day&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/f52975815e3ef251d5f903a55cc262b5dbe6e7c5/src/splot.jl#L3-L23">source</a></section></article><h2 id="stl"><a class="docs-heading-anchor" href="#stl">stl</a><a id="stl-1"></a><a class="docs-heading-anchor-permalink" href="#stl" title="Permalink"></a></h2><p><strong>Seasonal and Trend decomposition based on Loess</strong></p><article class="docstring"><header><a class="docstring-binding" id="Forecast.stl" href="#Forecast.stl"><code>Forecast.stl</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">stl(Yv, np; robust=false, 
            nl=nextodd(np), 
            ns=10*length(Yv)+1,
            nt=nextodd(1.5*np/(1-1.5/ns)), 
            ni=robust ? 1 : 2,
            no=0,
            spm=false,
            qsmp=max(div(np,7),2),
            cth = 0.01,
            timestamp = nothing,
            verbose=false)</code></pre><p>Decompose a time series into trend, seasonal, and remainder components.</p><p>&quot;STL has a simple design that consists of a sequence of applications of the loess smoother; the simplicity allows analysis of the properties of the procedure and allows fast computation, even for very long time series and large amounts of trend and seasonal smoothing. Other features of STL  are specification of amounts of seasonal and trend smoothing that range, in a nearly continous way, from very small amount of smoothing to a very large amount; robust estimates of the trend and seasonal components that are not distorted by aberrant behavior in the data; specification of the period of the seasonal component to any intenger multiple of the time sampling interval greater than one; and the ability to decompose time series with missing values.&quot;*</p><p>All default values are chosen following the recommendations of the original paper when those were recommended. <code>ns</code> is recommended to be chosen of the basis of knowledge of the time series and on the basis of diagnostic methods; it must nonethelessbe  always odd and at least 7. A default value is not advised on the original paper, instead the same default value used in the stl implementation in R in usere here.</p><p>for <code>no</code> the authors advise 5 (&quot;safe value&quot;) or 10 (&quot;near certainty of convergence&quot;) cycles  or a convergence criterion when robustness is required, in this case when <code>robust</code> is true computations stop when convergence is achieved in trend and seasonality.</p><p>for <code>qsmp</code> the authors do not adivise a default but they use a value close to div(<code>np</code>,7).</p><p><strong>Arguments</strong></p><ul><li><code>np</code>: Seasonality.</li><li><code>robust</code>: Robust stl.</li><li><code>nl</code>: Smoothing parameter of the low-pass filter.</li><li><code>ns</code>: Smoothing parameter for the seasonal component.</li><li><code>nt</code>: Smoothing parameter for the trend decomposition.</li><li><code>ni</code>: Number of inner loop cycles.</li><li><code>no</code>: Number of outer loop cycles.</li><li><code>spm</code>: Seasonal post-smoothing.</li><li><code>qsmp</code>: Loess q window for Seasonal post-smoothing.</li><li><code>cth</code>: Corvengence threshold for Seasonal and Trend.</li><li><code>timestamp</code>: Timestamp to be used other than the default.</li><li><code>verbose</code>: If true shows updates for the Seasonal and Trend convergence.</li></ul><p><strong>Returns</strong></p><p>An <code>STL</code> object with the seasonal, trend and remainder components.</p><ul><li><p>STL: A Seasonal, Trend Decomposition Procedure Based on Loess&quot; Robert B. Cleveland, William S. Cleveland, Jean E. McRae, and Irma Terpenning. Journal of Official Statistics Vol. 6. No. 1, 1990, pp. 3-73 (c) Statistics Sweden.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; stl_co2 = stl(co2(),365; robust=true, spm=true)
[ Info: Dataset used in Cleveland et al. paper
[ Info: Corvengence achieved (&lt; 0.01); Stopping computation...
STL Object: stl(Yn, np=365; nl=365, ns=46091, nt=549, ni=1, no=0, spm=true, qsmp=52)

julia&gt; plot(stl_co2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/f52975815e3ef251d5f903a55cc262b5dbe6e7c5/src/stl.jl#L1-L55">source</a></section></article><h2 id="summarize"><a class="docs-heading-anchor" href="#summarize">summarize</a><a id="summarize-1"></a><a class="docs-heading-anchor-permalink" href="#summarize" title="Permalink"></a></h2><p><strong>Statistical summary</strong></p><article class="docstring"><header><a class="docstring-binding" id="Forecast.summarize" href="#Forecast.summarize"><code>Forecast.summarize</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">summarize(x; varnames = nothing)</code></pre><p>Return statistical summary for x</p><p>The values returned are dividen in three sections, the first one shows Minimum, 1st Quantile, Median, Mean, 3rd Quantile, Maxixum and the p-value for the Jarque-Bera Normality Test. The second one show the first four moment; Mean, Variance, Skewness and Kurtosis, an finally a summary with the different types contained in the Array.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Array or DataFrame of data.</li><li><code>varnames</code>: Names for the columns to be summarized, it defaults to automatic naming           or the existing names in when a DataFrame.</li></ul><p><strong>Returns</strong></p><p>A SUMMARIZE struct</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; summarize(rand(100,3); varnames = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;])
┌──────────┬────────────┬──────────┬──────────┬──────────┬──────────┬──────────┬───────────┐
│ Variable │        Min │       1Q │   Median │     Mean │       3Q │      Max │ H0 Normal │
├──────────┼────────────┼──────────┼──────────┼──────────┼──────────┼──────────┼───────────┤
│        a │ 0.00520465 │ 0.205712 │ 0.462199 │ 0.465784 │   0.6913 │  0.97946 │ 0.0593599 │
│        b │ 0.00218787 │ 0.247344 │ 0.485465 │ 0.498587 │ 0.723371 │ 0.985226 │ 0.0562301 │
│        c │  0.0244256 │ 0.247598 │ 0.530821 │ 0.498689 │ 0.722731 │ 0.967952 │ 0.0356495 │
└──────────┴────────────┴──────────┴──────────┴──────────┴──────────┴──────────┴───────────┘
┌──────────┬──────────┬───────────┬───────────┬───────────┐
│ Variable │     Mean │  Variance │  Skewness │  Kurtosis │
├──────────┼──────────┼───────────┼───────────┼───────────┤
│        a │ 0.465784 │ 0.0823949 │ 0.0823949 │ 0.0823949 │
│        b │ 0.498587 │ 0.0854883 │ 0.0854883 │ 0.0854883 │
│        c │ 0.498689 │ 0.0790597 │ 0.0790597 │ 0.0790597 │
└──────────┴──────────┴───────────┴───────────┴───────────┘
┌──────────┬─────────┐
│ Variable │ Float64 │
├──────────┼─────────┤
│        a │     100 │
│        b │     100 │
│        c │     100 │
└──────────┴─────────┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/f52975815e3ef251d5f903a55cc262b5dbe6e7c5/src/summarize.jl#L1-L43">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/whatif/">« WHAT-IF Scenarios</a><a class="docs-footer-nextpage" href="../datasets/">Datasets »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 20 September 2021 19:21">Monday 20 September 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
