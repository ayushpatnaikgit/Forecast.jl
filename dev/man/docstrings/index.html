<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Docstrings · Forecast.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Forecast.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Forecast.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">What is this about?</a></li><li><a class="tocitem" href="../quickstart/">Quick Start</a></li><li><span class="tocitem">Forecast Examples</span><ul><li><a class="tocitem" href="../examples/quakes/">Quakes (Univariate)</a></li><li><a class="tocitem" href="../examples/airpassengers/">Air Passengers (Seasonality)</a></li><li><a class="tocitem" href="../examples/london/">London Weather/Crime (Multivariate)</a></li><li><a class="tocitem" href="../examples/whatif/">WHAT-IF Scenarios</a></li></ul></li><li><a class="tocitem" href="../methods/">Featured Methods</a></li><li><a class="tocitem" href="../datasets/">Datasets</a></li><li class="is-active"><a class="tocitem" href>Docstrings</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Docstrings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Docstrings</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/viraltux/Forecast.jl/blob/master/docs/src/man/docstrings.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Docstrings"><a class="docs-heading-anchor" href="#Docstrings">Docstrings</a><a id="Docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#Docstrings" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Forecast.Forecast" href="#Forecast.Forecast"><code>Forecast.Forecast</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Collection of methods for Time Series analysis</p><p>Featured Methods:</p><pre><code class="language-none">acf:        Auto-correlation or auto-covariance of univariate series. 
ar:         Multivariate Autoregressive Model.
arsim:      Simulated Multivariate Autoregressive Model.
boxcox:     Box-Cox Transformations.
ccf:        Cross-correlation or cros-covariance of two univariate series.
d:          Lagged differences of a given order for Vector and Array.
forecast:   Forecast values of fitted time series models.
hma:        Henderson moving average filter.
iboxcox:    Inverse Box-Cox Transformations.
loess:      Locally estimated scatterplot smoothing.
p:          Reverse lagged differences of a given order for types Vector and Array.
pacf:       Partial Auto-correlation function.
sma:        Simple moving average.
splot:      Plot a seasonal plot for types Vector and TimeArray.
stl:        Seasonal and Trend decomposition using loess.
summarize:  Statistical summary.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/Forecast.jl#L53-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.AR" href="#Forecast.AR"><code>Forecast.AR</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Package: Forecast</p><p>Store results from the function <code>ar</code></p><p><strong>Arguments</strong></p><p><code>varnames</code>        List of variable names <code>order</code>           Order of Autoregressive Model <code>ndims</code>           Number of dimensions <code>Φ</code>               Collection of d by d matrices of coefficients <code>coefficients</code>    Alias for Φ <code>Φ0</code>              Constant <code>constant</code>        Alias for Φ0 <code>Σ2</code>              ML variance/covariance Matrix <code>variance</code>        Alias for Σ2 <code>Σ</code>               Variables Standard deviation  <code>stdev</code>           Alias for Σ <code>x</code>               Original dataset <code>fitted</code>          Fitted values <code>residuals</code>       Prediction Error <code>ic::Dict</code>        Collection of Information Criteria <code>stats::Dict</code>     Collection of Statistics <code>Φse</code>             Parameters Standard Error <code>pse</code>             Alias for Φse <code>Φ0se</code>            Constant Standard Error <code>p0se</code>            Alias for Φ0se <code>Φpv</code>             p-value for Parameters <code>ppv</code>             Alias for Φpv <code>Φ0pv</code>            p-value for Constant <code>p0pv</code>            Alias for Φ0pv <code>call::String</code>    Method called to generate AR</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/AR.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.CCF" href="#Forecast.CCF"><code>Forecast.CCF</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Package: Forecast</p><p>Store results from the functions <code>acf</code>, <code>ccf</code> and <code>pacf</code></p><p><strong>Arguments</strong></p><p><code>ccf</code>    An array with results from ccf, acf and pacf <code>N</code>      Length of ccf <code>type    Type of CCF</code>lag<code>Maximum number of lags</code>alph<code>CI thresholds</code>ci<code>CI for the alpha</code>auto<code>Auto-correlation</code>call`   Method called to generate ccf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/CCF.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.FORECAST" href="#Forecast.FORECAST"><code>Forecast.FORECAST</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Package: Forecast</p><p>Store results from the function <code>forecast</code></p><p><strong>Arguments</strong></p><p>model:  Model object containing information about the fitted model.    x:      Original time series.    alpha:  The confidence levels associated with the prediction intervals.    mean:   Point forecasts.    lower:  Lower limits for prediction intervals.    upper:  Upper limits for prediction intervals.    se:     Standard Error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/FORECAST.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.STL" href="#Forecast.STL"><code>Forecast.STL</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Package: Forecast</p><p>Store results from the function stl</p><p><strong>Arguments</strong></p><pre><code class="language-none">`decomposition::DataFrame`    A time array with three time series from a fitted STL model
`call::String`                method called to generate ta</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/STL.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.SUMMARIZE" href="#Forecast.SUMMARIZE"><code>Forecast.SUMMARIZE</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Package: Forecast</p><p>Store results from the function <code>summarize</code></p><p><strong>Arguments</strong></p><p><code>quantiles::DataFrame</code>        DataFrame with the data quantiles for each column <code>moment::DataFrame</code>           DataFrame with the first four moments for each column <code>format::DataFrame</code>           DataFrame with number of types per column</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/SUMMARIZE.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.acf-Tuple{DataFrames.DataFrame}" href="#Forecast.acf-Tuple{DataFrames.DataFrame}"><code>Forecast.acf</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">acf(x::{AbstractVector,DataFrame},
    type = &quot;cor&quot;,
    lag = Integer(ceil(10*log10(length(x)))),
    alpha = (0.95,0.99))</code></pre><p>Compute the auto-correlation or auto-covariance for an univariate series.</p><p>The results are normalized to preserve homoscedasticity. The distribution used to normalize the data is an approximation of a Fisher Transformation via a Normal Distribution. There is a plot recipe for the returned object, if the type is <code>cor</code> the plot will also show confidence intervals for the given alpha values.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Vector or uni-dimensional DataFrame of data.</li><li><code>type</code>: Valid values are &quot;cor&quot; for correlation (default) and &quot;cov&quot; for convariance.</li><li><code>lag</code>: Maximum number of lags.</li><li><code>alpha</code>: A tuple with two thresholds (t1,t2) with t1 &lt;= t2 to plot confidence intervals. The default values are 0.95 and 0.99.</li></ul><p><strong>Returns</strong></p><p>A CCF object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = rand(100);
res = acf(x; type=&quot;cor&quot;);
plot(res)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/acf.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.air-Tuple{}" href="#Forecast.air-Tuple{}"><code>Forecast.air</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">air()</code></pre><p>Return the classic Box &amp; Jenkins airline data. Monthly totals of international airline passengers from 1949 to 1960.</p><p>Box, G. E. P., Jenkins, G. M. and Reinsel, G. C. (1976) <em>Time Series Analysis, Forecasting and Control.</em> Third Edition. Holden-Day. Series G.</p><p><strong>Returns</strong></p><p>Dataframe containing the descrived dataset.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; air()
71×2 DataFrame
 Row │ year        quakes 
     │ Date        Int64  
─────┼────────────────────
   1 │ 1950-01-01     138
   2 │ 1951-01-01     151
   3 │ 1952-01-01     181
   [...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/datasets.jl#L158-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.ar" href="#Forecast.ar"><code>Forecast.ar</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">ar(x::DataFrame, or, constant = true;             
                 alpha = 1.0, dΦ0 = nothing, dΦ = nothing)

ar(x::AbstractArray, or, constant = true; 
                     alpha = false, dΦ0 = nothing, dΦ = nothing, varnames = nothing)</code></pre><p>Fit a multivariate autoregressive series model.</p><p>The fitting is done via Ordinary Least Squared and implements the following model:</p><p class="math-container">\[Xt = \Phi_0 + \sum_{i=1}^p \Phi_i \cdot X_{t-i} + \mathcal{N}(\vec{0},\Sigma)\]</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Multivariate series each column containing a dimension and ordered by time ascending rows.</li><li><code>or</code>: Number of parameters Φ to be estimated.</li><li><code>constant</code>: If <code>true</code> <code>ar</code> estimates Φ0 otherwise it is assume to be zero.</li><li><code>alpha</code>: fixes to zero all coefficients which significance is below its value. It defaults to one.</li><li><code>dΦ0</code>: Tuple containing two Φ0 objects, the first one will act as an original reference to the second one and different values will be fixed in the fitting process to the values in the second Φ0.</li><li><code>dΦ</code>:  Equivalent to dΦ0 but for Φ.</li><li><code>varnames</code>: Names of the dimensions (by default xi where <code>i</code> is an integer)</li></ul><p><strong>Returns</strong></p><p>An AR object containing the model coefficients, the error sigma matrix, residuals and a collection of information criteria</p><p><strong>Examples</strong></p><p>```julia-repl julia&gt; ar(rand(100,2),2) AR([...])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/ar.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.arsim-Union{Tuple{T}, Tuple{AR, Integer}, Tuple{AR, Integer, Union{Nothing, AbstractArray{Union{Missing, T}, 1}}}} where T&lt;:Real" href="#Forecast.arsim-Union{Tuple{T}, Tuple{AR, Integer}, Tuple{AR, Integer, Union{Nothing, AbstractArray{Union{Missing, T}, 1}}}} where T&lt;:Real"><code>Forecast.arsim</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">arsim(Φ,Φ0,x0,n; Σ,E,fix)
arsim(AR,n;fix)</code></pre><p>Simulate a multivariate autoregressive series model.</p><p>The simulated series follows the model:</p><p class="math-container">\[Xt = \Phi_0 + \sum_{i=1}^p \Phi_i \cdot X_{t-i} + E\]</p><p><strong>Arguments</strong></p><ul><li><p><code>AR</code>:           AR struct coming from an <code>ar</code> model.</p></li><li><p><code>Φ</code>:            Array with dimensions (m,m,p) for the parameters in the AR model.</p></li><li><p><code>Φ0</code>:           Vector size <code>m</code> for the constant in the AR model. Default value is 0.</p></li><li><p><code>x0</code>:           Array with dimensions (m,p) for the initial value in the AR model. Default value is a random value from zero to one.</p></li><li><p><code>n</code>:            Number of simulations.</p></li><li><p><code>fix</code>:          Matrix{Union{Missing,Float64}} containing values to be fixed in th simulation.</p></li><li><p><code>Σ2</code>:           Variance Covariance matrix for the AR model with a MvNormal distribution for the noise. Default value is an identity Matrix.</p></li><li><p><code>E</code>:            Distribution for the error.</p></li></ul><p><strong>Returns</strong></p><p>A multivariate series simulating an AR model each column containing a dimension and ordered by time ascending rows.</p><p><strong>Examples</strong></p><p>```julia-repl julia&gt; arsim(1,1,1,10) 10-element Vector{Float64,1}: [...]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/arsim.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.boxcox-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Real" href="#Forecast.boxcox-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:Real"><code>Forecast.boxcox</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">boxcox(x::Vector)
boxcox(x::Vector, λ::Float64)  
boxcox(x::Vector, λ::Vector)</code></pre><p>Compute a Box-Cox power transformation given λ or (λ1,λ2) for data containing negative values, or compute an optimal power transformation if no λ or (λ1,λ2) is provided.</p><p class="math-container">\[x(\lambda) =
\begin{cases}
 \dfrac{x_i^\lambda - 1}{\lambda} &amp; \text{if } \lambda \neq 0 \\
 \ln x_i &amp; \text{if } \lambda = 0
\end{cases}\]</p><p>for negative values</p><p class="math-container">\[x(\boldsymbol{\lambda}) =
\begin{cases}
 \dfrac{(x_i + \lambda_2)^{\lambda_1} - 1}{\lambda_1} &amp; \text{if } \lambda_1 \neq 0 \\
 \ln (x_i + \lambda_2) &amp; \text{if } \lambda_1 = 0
\end{cases} \]</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Vector to be transformed.</li><li><code>λ</code>: Exponent/s for the tranformation</li></ul><p><strong>Returns</strong></p><p>A vector with a boxcox tarnsformation for <code>x</code> or a Dict with :x boxcox tranformed and the optimal :λ</p><p><strong>Reference</strong></p><p>Box, G. E. P. and Cox, D. R. (1964). An analysis of transformations, Journal of the Royal Statistical Society, Series B, 26, 211-252. A</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = rand(100)
julia&gt; bc = boxcox(x)
julia&gt; iboxcox(bc[:x],bc[:λ]) ≈ x

julia&gt; x = rand(100) .- 0.5
julia&gt; bc = boxcox(x)
julia&gt; iboxcox(bc[:x],bc[:λ]) ≈ x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/boxcox.jl#L2-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.ccf-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}" href="#Forecast.ccf-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}"><code>Forecast.ccf</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">ccf(x1::{AbstractVector,DataFrame},
    x2::{AbstractVector,DataFrame};
    type = &quot;cor&quot;,
    lag = Integer(ceil(10*log10(length(x1)))),
    alpha = (0.95,0.99))</code></pre><p>Compute the cross-correlation or cros-covariance of two univariate series.</p><p>The results are normalized to preserve homoscedasticity. The distribution used to normalize the data is an approximation of a Fisher Transformation via a Normal Distribution. There is a plot recipe for the returned object, if the type is <code>cor</code> the plot will also show confidence intervals for the given alpha values.</p><p>If, for a given integer <code>k</code>, <code>x2</code> repeats <code>x1</code> values such that x1[t] = x2[t+k] for all <code>i</code> then high correlation value will be placed <em>at the right from the center</em> in the results. That is, this convention will be represented in the plots as <code>x1_t = x2_{t+k} -&gt; _____0__k__</code> meaning x2 behavior can be predicted by x1 in k units.</p><p><strong>Arguments</strong></p><ul><li><code>x1</code>: Vector or uni-dimensional DataFrame of data.</li><li><code>x2</code>: Vector or uni-dimensional DataFrame of data.</li><li><code>type</code>: Valid values are &quot;cor&quot; for correlation (default) and &quot;cov&quot; for convariance.</li><li><code>lag</code>: Maximum number of lags.</li><li><code>alpha</code>: A tuple with two thresholds (t1,t2) with t1 &lt;= t2 to plot confidence intervals. The default values are 0.95 and 0.99.</li></ul><p><strong>Returns</strong></p><p>A CCF object. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x1 = rand(100);
x2 = circshift(x1,6);
res = ccf(x1, x2; type=&quot;cor&quot;);
plot(res)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/ccf.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.co2" href="#Forecast.co2"><code>Forecast.co2</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">co2(full = false)</code></pre><p>Return dataset with atmospheric Carbon Dioxide Dry Air Mole Fractions from quasi-continuous measurements at Mauna Loa, Hawaii.</p><p>K.W. Thoning, A.M. Crotwell, and J.W. Mund (2020), Atmospheric Carbon Dioxide Dry Air Mole Fractions from continuous measurements at Mauna Loa, Hawaii, Barrow, Alaska, American Samoa and South Pole. 1973-2019, Version 2020-08 National Oceanic and Atmospheric Administration (NOAA), Global Monitoring Laboratory (GML), Boulder, Colorado, USA https://doi.org/10.15138/yaf1-bk21 FTP path: ftp://aftp.cmdl.noaa.gov/data/greenhouse_gases/co2/in-situ/surface/</p><p><strong>Arguments</strong></p><ul><li><code>full</code>: if <code>true</code> Returns the full original dataset from 1973 to 2020 in a DataFrame, otherwise returns the subset used in &quot;STL: A Seasonal-Trend Decomposition Procedure Based on Loess&quot; from Cleveland et. al. Its default value is <code>false</code>.</li></ul><p><strong>Returns</strong></p><p>Dataframe containing the descrived dataset.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; co2()
[ Info: Dataset used in Cleveland et al. paper
4612×2 DataFrame
  Row │ date        co2        
      │ Date        Float64?   
──────┼────────────────────────
    1 │ 1974-05-17      333.38
    2 │ 1974-05-18      333.11
    3 │ 1974-05-19      333.46
   [...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/datasets.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.compact-Tuple{Any}" href="#Forecast.compact-Tuple{Any}"><code>Forecast.compact</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">compact(x)</code></pre><p>Standarize input by dropping empty dimensions and returning an Array. If a Number is passed then a 0-dimensional array is returned. In the case of a DataFrame it removes all non Real columns except if there are columns  with Date type in which case keeps the first one found and places  it as the first column.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/utils.jl#L29-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.d" href="#Forecast.d"><code>Forecast.d</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">function d(x::{AbstractVector,AbstractArray,DataFrame},
           or::Int=1,
           la::Int=1;
           center::Bool=false)</code></pre><p>Return Laged differences of a given or for Vector, Array and TimeSeries.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Vector or Array of data.</li><li><code>or</code>: Order of the differences; number of recursive iterations on the same vector/array.</li><li><code>la</code>: Lag for the difference.</li><li><code>center</code>: Center the result in the response using Missing values.</li></ul><p><strong>Returns</strong></p><p>Laged differences Vector or Array of a given order.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = [1,2,3,4,5];
julia&gt; d(x)
 d(x)
4-element Vector{Int64}:
 1
 1
 1
 1

julia&gt; d(x,2)
3-element Vector{Int64}:
 0
 0
 0


julia&gt; d(x,1,2)
3-element Vector{Int64}:
 2
 2
 2

julia&gt; x = reshape(collect(1:20),10,2);

julia&gt; d(x,2,2)
6×2 Matrix{Int64}:
 0  0
 0  0
 0  0
 0  0
 0  0
 0  0

julia&gt; d(d(x,1,2),1,2) == d(x,2,2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/d.jl#L1-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.drop-Tuple{AbstractMatrix{T} where T}" href="#Forecast.drop-Tuple{AbstractMatrix{T} where T}"><code>Forecast.drop</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">drop(M;r,c)</code></pre><p>Drop rows and columns from a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/utils.jl#L13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.expand-Tuple{Any, Tuple}" href="#Forecast.expand-Tuple{Any, Tuple}"><code>Forecast.expand</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">expand(x)</code></pre><p>Inverse of compact(x)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/utils.jl#L46-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.fixW-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer, Tuple{AbstractArray{T, N} where N, AbstractArray{T, N} where N}, Tuple{AbstractArray{T, N} where N, AbstractArray{T, N} where N}}} where T&lt;:Real" href="#Forecast.fixW-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer, Tuple{AbstractArray{T, N} where N, AbstractArray{T, N} where N}, Tuple{AbstractArray{T, N} where N, AbstractArray{T, N} where N}}} where T&lt;:Real"><code>Forecast.fixW</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">fixW(W,dΦ0,dΦ)</code></pre><p>For a given Weight matrix returns a version with fixed values based on dΦ0 and dΦ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/ar.jl#L244-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.fixnp-Union{Tuple{T}, Tuple{Tuple{AbstractArray{T, N} where N, AbstractArray{T, N} where N}, Tuple{AbstractArray{T, N} where N, AbstractArray{T, N} where N}}} where T&lt;:Real" href="#Forecast.fixnp-Union{Tuple{T}, Tuple{Tuple{AbstractArray{T, N} where N, AbstractArray{T, N} where N}, Tuple{AbstractArray{T, N} where N, AbstractArray{T, N} where N}}} where T&lt;:Real"><code>Forecast.fixnp</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">fixnp(dΦ0,dΦ)</code></pre><p>return the number of free parameters</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/ar.jl#L279-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.fixΦ-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, Integer, Tuple{AbstractArray{T, N} where N, AbstractArray{T, N} where N}, Tuple{AbstractArray{T, N} where N, AbstractArray{T, N} where N}}} where T&lt;:Real" href="#Forecast.fixΦ-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, Integer, Tuple{AbstractArray{T, N} where N, AbstractArray{T, N} where N}, Tuple{AbstractArray{T, N} where N, AbstractArray{T, N} where N}}} where T&lt;:Real"><code>Forecast.fixΦ</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">fixΦ(X,Y,dΦ0,dΦ)</code></pre><p>For a given X and Y OLS matrices returns the X and Y resulting from fixing parameters given dΦ0 and dΦ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/ar.jl#L201-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.fixΦse-Union{Tuple{T}, Tuple{AbstractVector{T}, Tuple{AbstractArray{T, N} where N, AbstractArray{T, N} where N}, Tuple{AbstractArray{T, N} where N, AbstractArray{T, N} where N}}} where T&lt;:Real" href="#Forecast.fixΦse-Union{Tuple{T}, Tuple{AbstractVector{T}, Tuple{AbstractArray{T, N} where N, AbstractArray{T, N} where N}, Tuple{AbstractArray{T, N} where N, AbstractArray{T, N} where N}}} where T&lt;:Real"><code>Forecast.fixΦse</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">fixΦse(M,dΦ0,dΦ)</code></pre><p>For a given <code>se</code> matrix returns an version with zeroes based on dΦ0 and dΦ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/ar.jl#L307-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.forecast-Union{Tuple{T}, Tuple{Any, Integer}} where T&lt;:Real" href="#Forecast.forecast-Union{Tuple{T}, Tuple{Any, Integer}} where T&lt;:Real"><code>Forecast.forecast</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">forecast(xar, n; levels = (0.8,.95))</code></pre><p>Forecast a univariate or multivariate autoregressive model.</p><p>The forecasting follows the model:</p><p class="math-container">\[Xt = \Phi_0 + \sum_{i=1}^p \Phi_i \cdot X_{t-i} + E\]</p><p><strong>Arguments</strong></p><p><code>xar</code>           AR struct coming from the <code>ar</code> function. <code>n</code>             Number of time periods to be forecasted. <code>alpha</code>         Prediction intervals levels; its default value is (0.8, 0.95) <code>fixMean</code>       Fixes the mean in the forecast with a DataFrame which first                  column is a timestamp type and missing values indicate values                 to be estimated. Default value is <code>nothing</code>. <code>fixΣ2</code>         fixes Σ2 values in the forecast</p><p><strong>Returns</strong></p><p>A FORECAST struct</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/forecast_ar.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.fvar-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, AbstractMatrix{T}, Integer}} where T&lt;:Real" href="#Forecast.fvar-Union{Tuple{T}, Tuple{AbstractArray{T, N} where N, AbstractMatrix{T}, Integer}} where T&lt;:Real"><code>Forecast.fvar</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Forecast recursive variance/covariance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/forecast_ar.jl#L102-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.hma-Tuple{AbstractArray{var&quot;#s47&quot;, N} where {var&quot;#s47&quot;&lt;:Real, N}, Integer}" href="#Forecast.hma-Tuple{AbstractArray{var&quot;#s47&quot;, N} where {var&quot;#s47&quot;&lt;:Real, N}, Integer}"><code>Forecast.hma</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">hma(s, n)</code></pre><p>Applies the Henderson moving average filter to dataset <code>s</code> with <code>n</code>-term.</p><p>&quot;Henderson moving averages are filters which were derived by Robert Henderson in 1916  for use in actuarial applications. They are trend filters, commonly used in time series  analysis to smooth seasonally adjusted estimates in order to generate a trend estimate.</p><p>They are used in preference to simpler moving averages because they can reproduce  polynomials of up to degree 3, thereby capturing trend turning points.</p><p>The ABS uses Henderson moving averages to produce trend estimates from a seasonally  adjusted series. The trend estimates published by the ABS are typically derived using  a 13 term Henderson filter for monthly series, and a 7 term Henderson filter for quarterly series.</p><p>Henderson filters can be either symmetric or asymmetric. Symmetric moving averages can be applied  at points which are sufficiently far away from the ends of a time series. In this case, the  smoothed value for a given point in the time series is calculated from an equal number of values  on either side of the data point.&quot; - Australian Bureau of Statistics (www.abs.gov.au)</p><p><strong>Arguments</strong></p><ul><li><code>s</code>: Observations&#39; support.</li><li><code>n</code>: Observation values. Tipically 13 or 7 for quarterly data, larger values may need a BigInt type.</li></ul><p><strong>Returns</strong></p><p>An array of Henderson filter smoothed values provided in <code>s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; hma(rand(1000), BigInt(303)))
1000-element Vector{BigFloat}:
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/hma.jl#L71-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.iboxcox-Tuple{AbstractVector{var&quot;#s19&quot;} where var&quot;#s19&quot;&lt;:Real, Real}" href="#Forecast.iboxcox-Tuple{AbstractVector{var&quot;#s19&quot;} where var&quot;#s19&quot;&lt;:Real, Real}"><code>Forecast.iboxcox</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">iboxcox(x::Vector, λ::Float64) 
iboxcox(x::Vector, λ::Vector)</code></pre><p>Compute the inverse transformation of a Box-Cox power transformation given λ.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Vector with a boxcox tranformation to be inverted.</li><li><code>λ</code>: Exponent for the inverse tranformation.</li></ul><p><strong>Returns</strong></p><p>A vector with witht the inverse transformation of x given λ.</p><p><strong>Reference</strong></p><p>Box, G. E. P. and Cox, D. R. (1964). An analysis of transformations, Journal of the Royal Statistical Society, Series B, 26, 211-252. A</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = rand(100)
julia&gt; bc = boxcox(x)
julia&gt; iboxcox(bc[:x],bc[:λ]) ≈ x

julia&gt; x = rand(100) .- 0.5
julia&gt; bc = boxcox(x)
julia&gt; iboxcox(bc[:x],bc[:λ]) ≈ x</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/boxcox.jl#L70-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.insert_column" href="#Forecast.insert_column"><code>Forecast.insert_column</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">insert_column(M, at, value = 0.0)</code></pre><p>Insert a column with specific value at a given position, values are pushed to the right</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/utils.jl#L57-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.insert_cross" href="#Forecast.insert_cross"><code>Forecast.insert_cross</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">insert_row(M, at, value = 0.0)</code></pre><p>Insert a row and a column with specific value at a given cross position,  values are pushed right and down.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/utils.jl#L91-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.insert_row" href="#Forecast.insert_row"><code>Forecast.insert_row</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">insert_row(M, at, value = 0.0)</code></pre><p>Insert a row with specific value at a given position, values are pushed down</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/utils.jl#L74-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.loess-Union{Tuple{V}, Tuple{T}, Tuple{S}, Tuple{R}, Tuple{AbstractVector{R}, AbstractVector{var&quot;#s41&quot;} where var&quot;#s41&quot;&lt;:Union{Missing, S}}} where {R&lt;:Real, S&lt;:Real, T&lt;:Real, V&lt;:Real}" href="#Forecast.loess-Union{Tuple{V}, Tuple{T}, Tuple{S}, Tuple{R}, Tuple{AbstractVector{R}, AbstractVector{var&quot;#s41&quot;} where var&quot;#s41&quot;&lt;:Union{Missing, S}}} where {R&lt;:Real, S&lt;:Real, T&lt;:Real, V&lt;:Real}"><code>Forecast.loess</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">loess(xv, yv;
      d = 2,
      q = Int64(round(3/4*length(xv))),
      rho = repeat([1.0],inner=length(xv)),  
      predict = xv)</code></pre><p>Smooth a vector of observations using locally weighted regressions.</p><p>Although loess can be used to smooth observations for any given number of independent variables, this implementation is univariate. The speed of loess can be greatly increased by using fast aproximations for the linear fitting calculations, however this implementation calculates only exact results.</p><p>The loess functionality and nomenclature follows the descriptions in:</p><p>&quot;STL: A Seasonal, Trend Decomposition Procedure Based on Loess&quot; Robert B. Cleveland, William S. Cleveland, Jean E. McRae, and Irma Terpenning. Journal of Official Statistics Vol. 6. No. 1, 1990, pp. 3-73 (c) Statistics Sweden.</p><p><strong>Arguments</strong></p><ul><li><code>xv</code>: Observations&#39; support.</li><li><code>yv</code>: Observation values.</li><li><code>d</code>: Degree of the linear fit, it accepts values 1 or 2.</li><li><code>q</code>: As q increases loess becomes smoother, when q tends to infinity loess tends to an ordinary least square poynomial fit of degree <code>d</code>. It defaults to the rounding of 3/4 of xv&#39;s length.<ul><li><code>rho</code>: Weights expressing the reliability of the observations (e.g. if yi had variances σ^2*ki where ki where known, the rhoi could be 1/ki). It defaults to 1.0.</li></ul></li><li><code>predict</code>: Vector containing the real values to be predicted, by default predicts xv.</li></ul><p><strong>Returns</strong></p><p>The loess values for the values contained in <code>predict</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; loess(rand(5), rand(5); predict=rand(10))
10-element Array{Float64,1}:
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/loess.jl#L36-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.london-Tuple{}" href="#Forecast.london-Tuple{}"><code>Forecast.london</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">london()</code></pre><p>Return ten years of monthly data about weather and crime in Greater London from 2008 to 2018.</p><p>Data has been collected and joined from london.gov.uk and metoffice.gov.uk (Heathrow Station).</p><p><strong>Weather Variables</strong></p><ul><li><code>MaxTemp</code>:  Mean daily maximum temperature in C°</li><li><code>MinTemp</code>:  Mean daily minimum temperature in C°</li><li><code>AirFrost</code>: Days of air frost</li><li><code>Rain</code>:     Total rainfall in mm</li><li><code>Sun</code>:      Total sunshine durationin hours</li></ul><p><strong>Crime Variables and its aggregated categories</strong></p><pre><code class="language-none">┌─────────────────────────────┬────────────────────────────────────────┐
│                       Crime │                               Category │
├─────────────────────────────┼────────────────────────────────────────┤
│                    Burglary │            Burglary in Other Buildings │
│                             │                 Burglary in a Dwelling │
│                      Damage │            Criminal Damage To Dwelling │
│                             │       Criminal Damage To Motor Vehicle │
│                             │      Criminal Damage To Other Building │
│                             │                  Other Criminal Damage │
│                       Drugs │                       Drug Trafficking │
│                             │                            Other Drugs │
│                             │                    Possession Of Drugs │
│                       Fraud │                     Counted per Victim │
│                             │                  Other Fraud &amp; Forgery │
│                       Other │                         Going Equipped │
│                             │                       Other Notifiable │
│                     Robbery │                      Business Property │
│                             │                      Personal Property │
│                      Sexual │                           Other Sexual │
│                             │                                   Rape │
│                       Theft │                  Handling Stolen Goods │
│                             │ Motor Vehicle Interference &amp; Tampering │
│                             │                            Other Theft │
│                             │                     Other Theft Person │
│                             │               Theft From Motor Vehicle │
│                             │                       Theft From Shops │
│                             │          Theft/Taking Of Motor Vehicle │
│                             │            Theft/Taking of Pedal Cycle │
│                    Violence │                    Assault with Injury │
│                             │                         Common Assault │
│                             │                   Grievous Bodily Harm │
│                             │                             Harassment │
│                             │                                 Murder │
│                             │                       Offensive Weapon │
│                             │                         Other violence │
│                             │                           Wounding/GBH │
└─────────────────────────────┴────────────────────────────────────────┘</code></pre><p><strong>Returns</strong></p><p>Dataframe containing the descrived dataset.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; london()
132×15 DataFrame
 Row │ Date        MaxTemp  MinTemp  AirFrost  
     │ Date        Float64  Float64  Int64     
─────┼─────────────────────────────────────────[...]
   1 │ 2008-01-01     10.4      4.7         0  
   2 │ 2008-02-01     11.0      2.0         7  
   3 │ 2008-03-01     10.6      3.7         2
   [...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/datasets.jl#L199-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.nextodd-Tuple{Real}" href="#Forecast.nextodd-Tuple{Real}"><code>Forecast.nextodd</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">nextodd(x)</code></pre><p>Return the smallest odd integer greater than or equal to <code>x</code>.        </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/utils.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.p" href="#Forecast.p"><code>Forecast.p</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">function p(dx, x0)</code></pre><p>Return reverse lagged differences of a given order for Vector, Array and DataFrame.</p><p><strong>Arguments</strong></p><ul><li><code>dx</code>: Array or DataFrame of data.</li><li><code>x0</code>: Initial constants the reverse difference. The default value represents an integration of order one and lag one with initial values at zero. The format for the initial values is Array{Real,3}(order, variable, lag)&quot;</li></ul><p><strong>Returns</strong></p><p>Lagged differences Vector or Array of a given order.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">
# Order two with Lag two
julia&gt; x = repeat(1:2,30);
julia&gt; dx = d(x,2,2);
julia&gt; x0 = zeros(2,1,2); # lag 2, 1 variable, order 1
julia&gt; x0[1,:,:] = collect(1:2);
julia&gt; p(dx,x0) ≈ x
true

# Calculation of π
julia&gt; x = 0:0.001:1;
julia&gt; y = sqrt.(1 .- x.^2);
julia&gt; isapprox(4*p(y)[end]/1000 , π, atol = 0.01)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/p.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.pacf-Tuple{DataFrames.DataFrame}" href="#Forecast.pacf-Tuple{DataFrames.DataFrame}"><code>Forecast.pacf</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">pacf(x::{AbstractVector,DataFrame};
     type = &quot;step-real&quot;,
     lag = Integer(ceil(10*log10(length(x)))),
     alpha = (0.95,0.99))</code></pre><p>Compute the partial auto-correlation for an univariate series.</p><p>There are two versions; the &quot;step&quot; version estimates the auto-regressive parameters of an increasing model, the &quot;real&quot; version estimates the actual partial auto-correlation by eliminating the linear information provided by the lags. When using the default type &quot;stepwise-real&quot; both versions are calculated.</p><p>The distribution used to estimate the confidence intervals is an approximation of a Fisher Transformation via a Normal Distribution. There is a plot recipe for the returned object.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Vector or uni-dimensional DataFrame of data.</li><li><code>type</code> = Valid values are &quot;stepwise&quot;, &quot;real&quot; and &quot;stepwise-real&quot;.</li><li><code>lag</code>: Maximum number of lags.</li><li><code>alpha</code>: A tuple with two thresholds (t1,t2) with t1 &lt;= t2 to plot confidence intervals. The default values are 0.95 and 0.99.</li></ul><p><strong>Returns</strong></p><p>A CCF object</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = rand(100);
res = pacf(x);
plot(res)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/pacf.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.quakes-Tuple{}" href="#Forecast.quakes-Tuple{}"><code>Forecast.quakes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">quakes()</code></pre><p>Return the number of earthquakes per year on earth with a magnitude higher or equal to six from 1950 to 2020. The data has been collected from https://earthquake.usgs.gov/ and aggregated.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; quakes()
71×2 DataFrame
 Row │ year        quakes 
     │ Date        Int64  
─────┼────────────────────
   1 │ 1950-01-01     138
   2 │ 1951-01-01     151
   3 │ 1952-01-01     181
   [...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/datasets.jl#L125-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.seaborne" href="#Forecast.seaborne"><code>Forecast.seaborne</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">seaborne(full = false)</code></pre><p>Return estimates of world seaborne trade from AIS data collected by Marine Traffic.</p><p>By default a DataFrame containing deadweight imports for France, Germany and the United Kingdom from 2015-04-01 to 2021-05-02 is returned, otherwise a DataFrame is returned for the same countries with import and exports for the below fields:</p><p>num<em>pc:     number of port calls mtc:        metric tons of cargo dwt:        deadweight tonnage suffix</em>ma:  30-day moving averages</p><p>Data available at UN COMTRADE Monitor.Cerdeiro, Komaromi, Liu and Saeed (2020). </p><p><strong>Returns</strong></p><p>Dataframe containing the seaborne dataset.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; seaborne()
[ Info: Seaborne deadweight trade imports from AIS
2199×4 DataFrame
  Row │ Date        France   Germany  UK     
      │ Date        Int64    Int64    Int64  
──────┼──────────────────────────────────────
    1 │ 2015-04-01   507946   878377  599573
    2 │ 2015-04-02   332043  1501614  772714
    3 │ 2015-04-03   810077   941663  262994
   [...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/datasets.jl#L67-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.setnames!-Tuple{Forecast.FORECAST, AbstractVector{String}}" href="#Forecast.setnames!-Tuple{Forecast.FORECAST, AbstractVector{String}}"><code>Forecast.setnames!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Rename data in FORECAST object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/FORECAST.jl#L43-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.sma-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T&lt;:Number" href="#Forecast.sma-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T&lt;:Number"><code>Forecast.sma</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">sma(x, n)
sma(x, n, center)</code></pre><p>Smooth a vector of data using a simple moving average.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Vector of data.</li><li><code>n</code>: Size of the moving average.</li><li><code>center</code>: if true centers the moving averaged values in the response padding with <code>missing</code> values, otherwise the padding takes place at the end.</li></ul><p><strong>Returns</strong></p><p>Vector of moving average smoothed values containing <code>missing</code> values to preserve the size of the original vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; sma(1:5,3,true)
5-element Array{Any,1}:
  missing
 2.0
 3.0
 4.0
  missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/sma.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.splot-Tuple{}" href="#Forecast.splot-Tuple{}"><code>Forecast.splot</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">splot(x, labels)</code></pre><p>Plot a seasonal plot of x considering the parameter <code>labels</code></p><p><strong>Arguments</strong></p><ul><li><code>x</code>: regular timed observations</li><li><code>labels</code>: This parameter accepts Integer, String and Vector values. When an Integer the labels are 1:labels, when a Vector the labels are specified within and when a String it accepts values &quot;month&quot;, &quot;day&quot; and &quot;quarter&quot; expecting the first value of x to fall in &quot;Jan&quot;, &quot;Mon&quot; or &quot;Q1&quot; unless x is a DataFrame in which case it is treated as a Time Series where the first Date typed column and value columns ares considered, observations are then automatically ordered either by &quot;month&quot;, &quot;day&quot; or &quot;quarter&quot; and labels may be use to rename the default values.</li></ul><p><strong>Returns</strong></p><p>Sesonal plot</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; splot(rand(120),&quot;month&quot;)
julia&gt; splot(rand(120),&quot;quarter&quot;)
julia&gt; splot(rand(120),&quot;day&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/splot.jl#L3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.stl-Tuple{DataFrames.DataFrame, Integer}" href="#Forecast.stl-Tuple{DataFrames.DataFrame, Integer}"><code>Forecast.stl</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">stl(Yv, np; robust=false, 
            nl=nextodd(np), 
            ns=10*length(Yv)+1,
            nt=nextodd(1.5*np/(1-1.5/ns)), 
            ni=robust ? 1 : 2,
            no=0,
            spm=false,
            qsmp=max(div(np,7),2),
            cth = 0.01,
            timestamp = nothing,
            verbose=false)</code></pre><p>Decompose a time series into trend, seasonal, and remainder components.</p><p>&quot;STL has a simple design that consists of a sequence of applications of the loess smoother; the simplicity allows analysis of the properties of the procedure and allows fast computation, even for very long time series and large amounts of trend and seasonal smoothing. Other features of STL  are specification of amounts of seasonal and trend smoothing that range, in a nearly continous way, from very small amount of smoothing to a very large amount; robust estimates of the trend and seasonal components that are not distorted by aberrant behavior in the data; specification of the period of the seasonal component to any intenger multiple of the time sampling interval greater than one; and the ability to decompose time series with missing values.&quot;*</p><p>All default values are chosen following the recommendations of the original paper when those were recommended. <code>ns</code> is recommended to be chosen of the basis of knowledge of the time series and on the basis of diagnostic methods; it must nonethelessbe  always odd and at least 7. A default value is not advised on the original paper, instead the same default value used in the stl implementation in R in usere here.</p><p>for <code>no</code> the authors advise 5 (&quot;safe value&quot;) or 10 (&quot;near certainty of convergence&quot;) cycles  or a convergence criterion when robustness is required, in this case when <code>robust</code> is true computations stop when convergence is achieved in trend and seasonality.</p><p>for <code>qsmp</code> the authors do not adivise a default but they use a value close to div(<code>np</code>,7).</p><p><strong>Arguments</strong></p><ul><li><code>np</code>: Seasonality.</li><li><code>robust</code>: Robust stl.</li><li><code>nl</code>: Smoothing parameter of the low-pass filter.</li><li><code>ns</code>: Smoothing parameter for the seasonal component.</li><li><code>nt</code>: Smoothing parameter for the trend decomposition.</li><li><code>ni</code>: Number of inner loop cycles.</li><li><code>no</code>: Number of outer loop cycles.</li><li><code>spm</code>: Seasonal post-smoothing.</li><li><code>qsmp</code>: Loess q window for Seasonal post-smoothing.</li><li><code>cth</code>: Corvengence threshold for Seasonal and Trend.</li><li><code>timestamp</code>: Timestamp to be used other than the default.</li><li><code>verbose</code>: If true shows updates for the Seasonal and Trend convergence.</li></ul><p><strong>Returns</strong></p><p>An <code>STL</code> object with the seasonal, trend and remainder components.</p><ul><li><p>STL: A Seasonal, Trend Decomposition Procedure Based on Loess&quot; Robert B. Cleveland, William S. Cleveland, Jean E. McRae, and Irma Terpenning. Journal of Official Statistics Vol. 6. No. 1, 1990, pp. 3-73 (c) Statistics Sweden.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; stl_co2 = stl(co2(),365; robust=true, spm=true)
[ Info: Dataset used in Cleveland et al. paper
[ Info: Corvengence achieved (&lt; 0.01); Stopping computation...
STL Object: stl(Yn, np=365; nl=365, ns=46091, nt=549, ni=1, no=0, spm=true, qsmp=52)

julia&gt; plot(stl_co2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/stl.jl#L1-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.summarize-Tuple{DataFrames.DataFrame}" href="#Forecast.summarize-Tuple{DataFrames.DataFrame}"><code>Forecast.summarize</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Package: Forecast</p><pre><code class="language-none">summarize(x; varnames = nothing)</code></pre><p>Return statistical summary for x</p><p>The values returned are dividen in three sections, the first one shows Minimum, 1st Quantile, Median, Mean, 3rd Quantile, Maxixum and the p-value for the Jarque-Bera Normality Test. The second one show the first four moment; Mean, Variance, Skewness and Kurtosis, an finally a summary with the different types contained in the Array.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Array or DataFrame of data.</li><li><code>varnames</code>: Names for the columns to be summarized, it defaults to automatic naming           or the existing names in when a DataFrame.</li></ul><p><strong>Returns</strong></p><p>A SUMMARIZE struct</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; summarize(rand(100,3); varnames = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;])
┌──────────┬────────────┬──────────┬──────────┬──────────┬──────────┬──────────┬───────────┐
│ Variable │        Min │       1Q │   Median │     Mean │       3Q │      Max │ H0 Normal │
├──────────┼────────────┼──────────┼──────────┼──────────┼──────────┼──────────┼───────────┤
│        a │ 0.00520465 │ 0.205712 │ 0.462199 │ 0.465784 │   0.6913 │  0.97946 │ 0.0593599 │
│        b │ 0.00218787 │ 0.247344 │ 0.485465 │ 0.498587 │ 0.723371 │ 0.985226 │ 0.0562301 │
│        c │  0.0244256 │ 0.247598 │ 0.530821 │ 0.498689 │ 0.722731 │ 0.967952 │ 0.0356495 │
└──────────┴────────────┴──────────┴──────────┴──────────┴──────────┴──────────┴───────────┘
┌──────────┬──────────┬───────────┬───────────┬───────────┐
│ Variable │     Mean │  Variance │  Skewness │  Kurtosis │
├──────────┼──────────┼───────────┼───────────┼───────────┤
│        a │ 0.465784 │ 0.0823949 │ 0.0823949 │ 0.0823949 │
│        b │ 0.498587 │ 0.0854883 │ 0.0854883 │ 0.0854883 │
│        c │ 0.498689 │ 0.0790597 │ 0.0790597 │ 0.0790597 │
└──────────┴──────────┴───────────┴───────────┴───────────┘
┌──────────┬─────────┐
│ Variable │ Float64 │
├──────────┼─────────┤
│        a │     100 │
│        b │     100 │
│        c │     100 │
└──────────┴─────────┘</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/summarize.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Forecast.transform" href="#Forecast.transform"><code>Forecast.transform</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Transform a FORECAST object value with given function</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/viraltux/Forecast.jl/blob/1f0680e5bf0970ce7ddd4afb91981f4f2007c0f5/src/FORECAST.jl#L77-L79">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../datasets/">« Datasets</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 20 September 2021 21:19">Monday 20 September 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
